Session: DML builders + Spring Batch writer integration
=========================================================

Added type-safe INSERT, UPDATE, DELETE, MERGE builders + Spring Batch writer
integration, completing the write side to match the existing SELECT DSL.

Files added
-----------
- InsertBuilder.java         single/multi-row, set() API, insertFrom, returning, buildTemplate
- UpdateBuilder.java         set/setNull/setIfPresent/setSubquery, WHERE guard, returning, buildTemplate
- DeleteBuilder.java         WHERE guard, buildUnconditional, returning
- MergeBuilder.java          Oracle MERGE: DUAL/subquery source, multi-key ON, matched update/delete/set, not-matched insert
- BatchDmlProvider.java      @FunctionalInterface for DML (mirrors BatchQueryProvider)
- BatchWriterFactory.java    creates JdbcBatchItemWriter via JdbcBatchItemWriterBuilder
- DmlProviderRegistry.java   named lookup (mirrors QueryProviderRegistry)
- DmlBuilderTests.java       33 standalone tests

Files modified
--------------
- SpringBatchQueryConfig.java  + batchWriterFactory + dmlProviderRegistry beans
- CLAUDE.md                    + DML entry points, write-side Spring docs, new design decisions

Design decisions
----------------
1. SET uses column.name() (unqualified); WHERE uses column.ref() (alias-qualified).
   Oracle: UPDATE orders o SET amount = :v WHERE o.id = :v

2. build() on Update/Delete requires WHERE (safety). buildUnconditional() opts out.

3. buildTemplate() emits :col_name (no _N suffix), empty param map — for
   Spring Batch ItemSqlParameterSourceProvider per-item binding.

4. Multi-row INSERT uses Oracle INSERT ALL INTO ... SELECT 1 FROM DUAL.

5. MergeBuilder.ColumnValue<T> record preserves type safety in usingDual().

6. RETURNING clause: Oracle RETURNING col INTO :col. Included in build(), not buildTemplate().

Discoveries
-----------
1. ItemSqlParameterSourceProvider lives in org.springframework.batch.item.database,
   NOT org.springframework.jdbc.core.namedparam. Spring Batch moved it.

2. sealed interfaces (Java 17) work well for internal SET clause variants
   (ValueSetClause, NullSetClause, SubquerySetClause) — exhaustive pattern matching.

3. JdbcBatchItemWriterBuilder handles named params natively — no manual
   toPositional() conversion needed (unlike reader side).

Test results
------------
AllGapsTest:          25/25
EdgeCaseTests:        66/66
SpringBatchTests:      8/8
SpringContextTest:     6/6
OrderEnrichmentTest:  10/10
DmlBuilderTests:      33/33  ← NEW
Total:               148/148

========================================================================

Session: Order enrichment batch job (read → process → DB + CSV)
================================================================

Added read-process-write batch job: reads PENDING orders via 3-way DSL join
(orders+customers+products), enriches with tax/discount/priority, writes to
both order_summaries DB table and output/order_summary.csv via CompositeItemWriter.

Files added
-----------
- OrderDetailDto.java            Reader output record (order+customer+product)
- EnrichedOrderDto.java          Processor output record (tax/discount/priority)
- OrderEnrichmentJobConfig.java  Full job config: provider, reader, processor, 2 writers, step, job
- OrderEnrichmentTest.java       10 integration tests

Files modified
--------------
- schema.sql           + order_summaries table
- application.yml      + spring.batch.job.name (multi-job requirement)
- SpringContextTest.java  Bean-by-name lookups, registry size 2→3
- CLAUDE.md            + test commands for context + enrichment tests

Pipeline
--------
Reader  → JdbcCursorItemReader via DSL (3-way join, WHERE status=PENDING, ORDER BY amount DESC)
Processor → tax=10%, discount=GOLD 15%/SILVER 10%, finalAmount=amount+tax-discount, priority=HIGH if ≥1000
Writers → CompositeItemWriter[JdbcBatchItemWriter→order_summaries, FlatFileItemWriter→CSV]

Discoveries
-----------
1. Boot 3.2 + multiple Job beans: spring.batch.job.name required even when
   spring.batch.job.enabled=false. JobLauncherApplicationRunner.afterPropertiesSet()
   enforces unconditionally.

2. CompositeItemWriter (Batch 5.1 / Boot 3.2.3) extends AbstractItemStreamItemWriter
   → delegates open()/close() to ItemStream children automatically. No manual
   .stream() registration on step needed.

3. Records + JdbcBatchItemWriter: BeanPropertyItemSqlParameterSourceProvider fails
   (no getX() convention). Use ItemPreparedStatementSetter with positional ? instead.

4. Records + FlatFileItemWriter: BeanWrapperFieldExtractor same issue. Custom
   lineAggregator calling record accessors directly is cleaner and explicit.

5. JdbcBatchItemWriterBuilder.build() calls afterPropertiesSet() internally →
   writer fully initialized when returned from @Bean.

Test results
------------
AllGapsTest:          25/25
EdgeCaseTests:        66/66
SpringBatchTests:      8/8
SpringContextTest:     6/6
OrderEnrichmentTest:  10/10  ← NEW
Total:               115/115

========================================================================

Session: Review, fix comments, bugs, add IfPresent variants, document gaps
=========================================================================

Full review pass: fixed inaccurate comments, 3 bugs, added 6 missing IfPresent
condition variants, collapsed duplicate dialects, documented uncovered use cases.

Files modified
--------------
- Conditions.java             Fixed and/or Javadoc ("filters nulls, throws if none remain"),
                              added unsupported block, added 6 IfPresent variants:
                              neqIfPresent, gtIfPresent, ltIfPresent, likeIfPresent,
                              startsWithIfPresent, notInIfPresent
- SimpleCondition.java        Error msg: "Use eqIfPresent()" → "Use the IfPresent variant or isNull()"
- SelectBuilder.java          Fixed buildSubquery() Javadoc, having() Javadoc, CTE binder warning,
                              added unsupported block (FOR UPDATE, NULLS FIRST/LAST, window fns, etc.)
- UpdateBuilder.java          Added unsupported block (JOIN, arithmetic SET, CASE SET)
- MergeBuilder.java           Added unsupported block (conditional WHEN), inline comments in validate()
- InsertBuilder.java          Inline comment on SELECT 1 FROM DUAL
- Dialects.java               Collapsed duplicate ORACLE impl → alias for ANSI
- ExpressionValidator.java    Bug fix: identifier regex [a-zA-Z0-9_ ]* → [a-zA-Z0-9_.]*
                              (spaces invalid, dots needed for qualified refs), added class/inline Javadoc
- BatchWriterFactory.java     Bug fix: added result.verify() after buildDml() (match reader)
- QueryDebugger.java          Bug fix: null guard on param value to prevent NPE, added class Javadoc
- BatchReaderFactory.java     Fixed afterPropertiesSet() comment
- SchemaValidator.java        Inline comment on Oracle uppercase COLUMN_NAME
- Column.java                 Added class Javadoc (ref vs name, aggregate helpers)
- CompositeCondition.java     Added class Javadoc
- BetweenCondition.java       Added class Javadoc
- LikeCondition.java          Added class Javadoc
- InListCondition.java        Added class Javadoc
- NullCondition.java          Added class Javadoc
- ColumnCondition.java        Added class Javadoc
- SubqueryCondition.java      Added class Javadoc
- ExistsCondition.java        Added class Javadoc
- RawCondition.java           Added class Javadoc
- UnionBuilder.java           Added class Javadoc + unsupported block
- ParameterBinder.java        Added class Javadoc
- AllGapsTest.java            Updated assertion to match new error message
- CLAUDE.md                   Updated IfPresent list, dialect section, docs index
- docs/README.md              Added unsupported.md link

Files added
-----------
- docs/unsupported.md         Consolidated unsupported features + workarounds by component

Bug fixes
---------
1. ExpressionValidator: identifier regex allowed spaces, disallowed dots
2. BatchWriterFactory: missing verify() — reader had it, writer didn't
3. QueryDebugger: NPE when parameter value is null

Test results
------------
AllGapsTest:          25/25
EdgeCaseTests:        66/66
SpringBatchTests:      8/8
DmlBuilderTests:      33/33
Total:               132/132

========================================================================

Session: Project documentation (docs/)
=======================================

Created comprehensive documentation in docs/ directory, distributed across
8 files by topic.

Files added
-----------
- docs/README.md            Index, quick example, build commands
- docs/architecture.md      Package structure, component diagrams, data flow, core abstractions
- docs/getting-started.md   Table definitions, first SELECT/INSERT/UPDATE/DELETE, result usage, debugging
- docs/select-builder.md    Full SELECT API: JOINs, CTEs, UNIONs, subqueries, pagination, aggregates
- docs/dml-builders.md      INSERT (SET/columnar/multi-row/INSERT FROM), UPDATE, DELETE, MERGE
- docs/conditions.md        Strict vs optional, all condition types, composition, subqueries, generics
- docs/spring-batch.md      Providers, reader/writer factories, registries, complete job example
- docs/design-decisions.md  10 patterns, trade-offs, 14 design gaps table
- docs/security.md          Parameterization, expression validation, blocked patterns, recommendations

Files modified
--------------
- CLAUDE.md                 + Documentation section with docs/ index

Discoveries
-----------
1. Project has 53 source files total (20 core DSL, 4 Spring integration,
   5 examples, 6 test classes, plus validation/debug utilities).

2. 148 standalone tests across 6 test classes, all passing. Tests cover
   14 design gaps, edge cases (nulls/injection/concurrency), Spring Batch
   integration, Spring context, DML builders, and order enrichment pipeline.

3. Sealed interfaces used for UpdateBuilder.SetClause variants — enables
   exhaustive pattern matching for ValueSetClause/NullSetClause/SubquerySetClause.

========================================================================

Session: Arithmetic SET + CASE expressions
============================================

Added arithmetic SET expressions (col = col + val) and CASE expressions
(searched + simple) across all builders. Refactored SelectBuilder's select
clause from String to List<SelectItem> for expression support.

Files added
-----------
- ArithmeticOp.java             Enum: ADD(+), SUBTRACT(-), MULTIPLY(*), DIVIDE(/)
- CaseExpression.java           Searched CASE: CASE WHEN cond THEN val ... END
- SimpleCaseExpression.java     Simple CASE: CASE col WHEN val THEN val ... END
- Cases.java                    Fluent builders: Cases.when()/Cases.of() with step chaining
- ArithmeticAndCaseTests.java   22 standalone tests

Files modified
--------------
- UpdateBuilder.java            + setAdd/setSubtract/setMultiply/setDivide/setArithmetic/setColumnExpr/setCase,
                                + ArithmeticSetClause/ColumnArithmeticSetClause/CaseSetClause sealed records,
                                + toTemplateSql() default on SetClause, buildTemplate() uses it,
                                removed "unsupported arithmetic/CASE" from Javadoc
- MergeBuilder.java             + whenMatchedSetAdd/Subtract/Multiply/Divide/Case,
                                + MatchedArithmeticEntry/MatchedCaseEntry records,
                                updated build() WHEN MATCHED + validate() hasWhen check
- SelectBuilder.java            Refactored selectClause String → List<SelectItem> sealed interface,
                                + selectExpr(Condition...) appends expressions,
                                + orderByExpr(Condition, SortDirection) overload,
                                + RawSelectItem/ExprSelectItem records
- docs/unsupported.md           Removed arithmetic SET + CASE entries
- docs/dml-builders.md          + arithmetic SET, CASE in SET, MERGE arithmetic/CASE examples
- docs/select-builder.md        + selectExpr(), CASE examples, ORDER BY with CASE
- CLAUDE.md                     + Cases.* entry point, arithmetic & CASE test command

Design decisions
----------------
1. Arithmetic SET methods bounded to Column<T extends Number> for type safety.
   setColumnExpr uses Column<?> (no bound) since column-to-column arithmetic
   has no value parameter to constrain.

2. toTemplateSql() default on SetClause returns col = :col (existing behavior).
   ArithmeticSetClause overrides: col = col + :col. ColumnArithmeticSetClause:
   col = left + right. CaseSetClause throws UnsupportedOperationException.

3. CASE classes implement Condition (reuse toSql(ParameterBinder) contract).
   CaseExpression.as() returns new instance with alias — use alias for SELECT,
   omit for SET/ORDER BY.

4. SelectBuilder List refactor: select()/selectDistinct()/selectRaw() clear list,
   selectExpr() appends. Preserves existing overwrite semantics while enabling
   mixed column + expression selects.

5. orderByExpr(Condition, SortDirection) renders CASE eagerly via binder —
   consistent with join() which also renders conditions immediately.

Test results
------------
ArithmeticAndCaseTests: 22/22  ← NEW
AllGapsTest:            25/25
EdgeCaseTests:          66/66
SpringBatchTests:        8/8
DmlBuilderTests:        33/33
Total:                 154/154
