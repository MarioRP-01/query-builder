Session: DML builders + Spring Batch writer integration
=========================================================

Added type-safe INSERT, UPDATE, DELETE, MERGE builders + Spring Batch writer
integration, completing the write side to match the existing SELECT DSL.

Files added
-----------
- InsertBuilder.java         single/multi-row, set() API, insertFrom, returning, buildTemplate
- UpdateBuilder.java         set/setNull/setIfPresent/setSubquery, WHERE guard, returning, buildTemplate
- DeleteBuilder.java         WHERE guard, buildUnconditional, returning
- MergeBuilder.java          Oracle MERGE: DUAL/subquery source, multi-key ON, matched update/delete/set, not-matched insert
- BatchDmlProvider.java      @FunctionalInterface for DML (mirrors BatchQueryProvider)
- BatchWriterFactory.java    creates JdbcBatchItemWriter via JdbcBatchItemWriterBuilder
- DmlProviderRegistry.java   named lookup (mirrors QueryProviderRegistry)
- DmlBuilderTests.java       33 standalone tests

Files modified
--------------
- SpringBatchQueryConfig.java  + batchWriterFactory + dmlProviderRegistry beans
- CLAUDE.md                    + DML entry points, write-side Spring docs, new design decisions

Design decisions
----------------
1. SET uses column.name() (unqualified); WHERE uses column.ref() (alias-qualified).
   Oracle: UPDATE orders o SET amount = :v WHERE o.id = :v

2. build() on Update/Delete requires WHERE (safety). buildUnconditional() opts out.

3. buildTemplate() emits :col_name (no _N suffix), empty param map — for
   Spring Batch ItemSqlParameterSourceProvider per-item binding.

4. Multi-row INSERT uses Oracle INSERT ALL INTO ... SELECT 1 FROM DUAL.

5. MergeBuilder.ColumnValue<T> record preserves type safety in usingDual().

6. RETURNING clause: Oracle RETURNING col INTO :col. Included in build(), not buildTemplate().

Discoveries
-----------
1. ItemSqlParameterSourceProvider lives in org.springframework.batch.item.database,
   NOT org.springframework.jdbc.core.namedparam. Spring Batch moved it.

2. sealed interfaces (Java 17) work well for internal SET clause variants
   (ValueSetClause, NullSetClause, SubquerySetClause) — exhaustive pattern matching.

3. JdbcBatchItemWriterBuilder handles named params natively — no manual
   toPositional() conversion needed (unlike reader side).

Test results
------------
AllGapsTest:          25/25
EdgeCaseTests:        66/66
SpringBatchTests:      8/8
SpringContextTest:     6/6
OrderEnrichmentTest:  10/10
DmlBuilderTests:      33/33  ← NEW
Total:               148/148

========================================================================

Session: Order enrichment batch job (read → process → DB + CSV)
================================================================

Added read-process-write batch job: reads PENDING orders via 3-way DSL join
(orders+customers+products), enriches with tax/discount/priority, writes to
both order_summaries DB table and output/order_summary.csv via CompositeItemWriter.

Files added
-----------
- OrderDetailDto.java            Reader output record (order+customer+product)
- EnrichedOrderDto.java          Processor output record (tax/discount/priority)
- OrderEnrichmentJobConfig.java  Full job config: provider, reader, processor, 2 writers, step, job
- OrderEnrichmentTest.java       10 integration tests

Files modified
--------------
- schema.sql           + order_summaries table
- application.yml      + spring.batch.job.name (multi-job requirement)
- SpringContextTest.java  Bean-by-name lookups, registry size 2→3
- CLAUDE.md            + test commands for context + enrichment tests

Pipeline
--------
Reader  → JdbcCursorItemReader via DSL (3-way join, WHERE status=PENDING, ORDER BY amount DESC)
Processor → tax=10%, discount=GOLD 15%/SILVER 10%, finalAmount=amount+tax-discount, priority=HIGH if ≥1000
Writers → CompositeItemWriter[JdbcBatchItemWriter→order_summaries, FlatFileItemWriter→CSV]

Discoveries
-----------
1. Boot 3.2 + multiple Job beans: spring.batch.job.name required even when
   spring.batch.job.enabled=false. JobLauncherApplicationRunner.afterPropertiesSet()
   enforces unconditionally.

2. CompositeItemWriter (Batch 5.1 / Boot 3.2.3) extends AbstractItemStreamItemWriter
   → delegates open()/close() to ItemStream children automatically. No manual
   .stream() registration on step needed.

3. Records + JdbcBatchItemWriter: BeanPropertyItemSqlParameterSourceProvider fails
   (no getX() convention). Use ItemPreparedStatementSetter with positional ? instead.

4. Records + FlatFileItemWriter: BeanWrapperFieldExtractor same issue. Custom
   lineAggregator calling record accessors directly is cleaner and explicit.

5. JdbcBatchItemWriterBuilder.build() calls afterPropertiesSet() internally →
   writer fully initialized when returned from @Bean.

Test results
------------
AllGapsTest:          25/25
EdgeCaseTests:        66/66
SpringBatchTests:      8/8
SpringContextTest:     6/6
OrderEnrichmentTest:  10/10  ← NEW
Total:               115/115

========================================================================

Session: Project documentation (docs/)
=======================================

Created comprehensive documentation in docs/ directory, distributed across
8 files by topic.

Files added
-----------
- docs/README.md            Index, quick example, build commands
- docs/architecture.md      Package structure, component diagrams, data flow, core abstractions
- docs/getting-started.md   Table definitions, first SELECT/INSERT/UPDATE/DELETE, result usage, debugging
- docs/select-builder.md    Full SELECT API: JOINs, CTEs, UNIONs, subqueries, pagination, aggregates
- docs/dml-builders.md      INSERT (SET/columnar/multi-row/INSERT FROM), UPDATE, DELETE, MERGE
- docs/conditions.md        Strict vs optional, all condition types, composition, subqueries, generics
- docs/spring-batch.md      Providers, reader/writer factories, registries, complete job example
- docs/design-decisions.md  10 patterns, trade-offs, 14 design gaps table
- docs/security.md          Parameterization, expression validation, blocked patterns, recommendations

Files modified
--------------
- CLAUDE.md                 + Documentation section with docs/ index

Discoveries
-----------
1. Project has 53 source files total (20 core DSL, 4 Spring integration,
   5 examples, 6 test classes, plus validation/debug utilities).

2. 148 standalone tests across 6 test classes, all passing. Tests cover
   14 design gaps, edge cases (nulls/injection/concurrency), Spring Batch
   integration, Spring context, DML builders, and order enrichment pipeline.

3. Sealed interfaces used for UpdateBuilder.SetClause variants — enables
   exhaustive pattern matching for ValueSetClause/NullSetClause/SubquerySetClause.
