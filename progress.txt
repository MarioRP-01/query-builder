Session: DML builders + Spring Batch writer integration
=========================================================

Added type-safe INSERT, UPDATE, DELETE, MERGE builders + Spring Batch writer
integration, completing the write side to match the existing SELECT DSL.

Files added
-----------
- InsertBuilder.java         single/multi-row, set() API, insertFrom, returning, buildTemplate
- UpdateBuilder.java         set/setNull/setIfPresent/setSubquery, WHERE guard, returning, buildTemplate
- DeleteBuilder.java         WHERE guard, buildUnconditional, returning
- MergeBuilder.java          Oracle MERGE: DUAL/subquery source, multi-key ON, matched update/delete/set, not-matched insert
- BatchDmlProvider.java      @FunctionalInterface for DML (mirrors BatchQueryProvider)
- BatchWriterFactory.java    creates JdbcBatchItemWriter via JdbcBatchItemWriterBuilder
- DmlProviderRegistry.java   named lookup (mirrors QueryProviderRegistry)
- DmlBuilderTests.java       33 standalone tests

Files modified
--------------
- SpringBatchQueryConfig.java  + batchWriterFactory + dmlProviderRegistry beans
- CLAUDE.md                    + DML entry points, write-side Spring docs, new design decisions

Design decisions
----------------
1. SET uses column.name() (unqualified); WHERE uses column.ref() (alias-qualified).
   Oracle: UPDATE orders o SET amount = :v WHERE o.id = :v

2. build() on Update/Delete requires WHERE (safety). buildUnconditional() opts out.

3. buildTemplate() emits :col_name (no _N suffix), empty param map — for
   Spring Batch ItemSqlParameterSourceProvider per-item binding.

4. Multi-row INSERT uses Oracle INSERT ALL INTO ... SELECT 1 FROM DUAL.

5. MergeBuilder.ColumnValue<T> record preserves type safety in usingDual().

6. RETURNING clause: Oracle RETURNING col INTO :col. Included in build(), not buildTemplate().

Discoveries
-----------
1. ItemSqlParameterSourceProvider lives in org.springframework.batch.item.database,
   NOT org.springframework.jdbc.core.namedparam. Spring Batch moved it.

2. sealed interfaces (Java 17) work well for internal SET clause variants
   (ValueSetClause, NullSetClause, SubquerySetClause) — exhaustive pattern matching.

3. JdbcBatchItemWriterBuilder handles named params natively — no manual
   toPositional() conversion needed (unlike reader side).

Test results
------------
AllGapsTest:          25/25
EdgeCaseTests:        66/66
SpringBatchTests:      8/8
SpringContextTest:     6/6
OrderEnrichmentTest:  10/10
DmlBuilderTests:      33/33  ← NEW
Total:               148/148

========================================================================

Session: Order enrichment batch job (read → process → DB + CSV)
================================================================

Added read-process-write batch job: reads PENDING orders via 3-way DSL join
(orders+customers+products), enriches with tax/discount/priority, writes to
both order_summaries DB table and output/order_summary.csv via CompositeItemWriter.

Files added
-----------
- OrderDetailDto.java            Reader output record (order+customer+product)
- EnrichedOrderDto.java          Processor output record (tax/discount/priority)
- OrderEnrichmentJobConfig.java  Full job config: provider, reader, processor, 2 writers, step, job
- OrderEnrichmentTest.java       10 integration tests

Files modified
--------------
- schema.sql           + order_summaries table
- application.yml      + spring.batch.job.name (multi-job requirement)
- SpringContextTest.java  Bean-by-name lookups, registry size 2→3
- CLAUDE.md            + test commands for context + enrichment tests

Pipeline
--------
Reader  → JdbcCursorItemReader via DSL (3-way join, WHERE status=PENDING, ORDER BY amount DESC)
Processor → tax=10%, discount=GOLD 15%/SILVER 10%, finalAmount=amount+tax-discount, priority=HIGH if ≥1000
Writers → CompositeItemWriter[JdbcBatchItemWriter→order_summaries, FlatFileItemWriter→CSV]

Discoveries
-----------
1. Boot 3.2 + multiple Job beans: spring.batch.job.name required even when
   spring.batch.job.enabled=false. JobLauncherApplicationRunner.afterPropertiesSet()
   enforces unconditionally.

2. CompositeItemWriter (Batch 5.1 / Boot 3.2.3) extends AbstractItemStreamItemWriter
   → delegates open()/close() to ItemStream children automatically. No manual
   .stream() registration on step needed.

3. Records + JdbcBatchItemWriter: BeanPropertyItemSqlParameterSourceProvider fails
   (no getX() convention). Use ItemPreparedStatementSetter with positional ? instead.

4. Records + FlatFileItemWriter: BeanWrapperFieldExtractor same issue. Custom
   lineAggregator calling record accessors directly is cleaner and explicit.

5. JdbcBatchItemWriterBuilder.build() calls afterPropertiesSet() internally →
   writer fully initialized when returned from @Bean.

Test results
------------
AllGapsTest:          25/25
EdgeCaseTests:        66/66
SpringBatchTests:      8/8
SpringContextTest:     6/6
OrderEnrichmentTest:  10/10  ← NEW
Total:               115/115
